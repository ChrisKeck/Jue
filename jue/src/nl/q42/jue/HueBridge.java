package nl.q42.jue;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URLEncoder;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;

import nl.q42.jue.Networker.Result;
import nl.q42.jue.exceptions.ApiException;
import nl.q42.jue.exceptions.LinkButtonException;
import nl.q42.jue.exceptions.UnauthorizedException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.reflect.TypeToken;

/**
 * Representation of a connection with a Hue bridge.
 */
public class HueBridge {
	private final static String DATE_FORMAT = "yyyy-MM-dd'T'HH:mm:ss";
	
	private String ip;
	private String username;
	
	private Gson gson = new GsonBuilder().setDateFormat(DATE_FORMAT).create();
	
	/**
	 * Connect with a bridge as a new user.
	 * @param ip ip address of bridge
	 */
	public HueBridge(String ip) {
		this.ip = ip;
	}
	
	/**
	 * Connect with a bridge as an existing user.
	 * @param ip ip address of bridge
	 * @param username username to authenticate with
	 */
	public HueBridge(String ip, String username) {
		this.ip = ip;
		this.username = username;
	}
	
	/**
	 * Returns the username currently authenticated with or null if there isn't one.
	 * @return username or null
	 */
	public String getUsername() {
		return username;
	}
	
	/**
	 * Returns basic configuration of the bridge (name and firmware version) and
	 * more detailed info if there is an authenticated user.
	 * @see Config
	 * @return Config or AuthenticatedConfig if authenticated
	 */
	public Config getConfig() throws IOException, ApiException {
		Result result = Networker.get(getRelativeURL("config"));
		handleErrors(result);
		
		if (username == null) {
			return safeFromJson(result.getBody(), Config.class);
		} else {
			return safeFromJson(result.getBody(), AuthenticatedConfig.class);
		}
	}
	
	/**
	 * Link with bridge using the specified username and device type.
	 * @param username username for new user [10..40]
	 * @param devicetype identifier of application [0..40]
	 * @throws ApiException throws LinkButtonException if the bridge button has not been pressed, ApiException for other errors
	 */
	public void link(String username, String devicetype) throws IOException, ApiException {
		this.username = link(new CreateUserRequest(username, devicetype));
	}
	
	/**
	 * Link with bridge using the specified device type. A random valid username will be generated by the bridge and returned.
	 * @return new random username generated by bridge
	 * @param devicetype identifier of application [0..40]
	 * @throws ApiException throws LinkButtonException if the bridge button has not been pressed, ApiException for other errors
	 */
	public String link(String devicetype) throws IOException, ApiException {
		return (this.username = link(new CreateUserRequest(devicetype)));
	}
	
	private String link(CreateUserRequest request) throws IOException, ApiException {
		if (this.username != null) {
			throw new IllegalStateException("already linked");
		}
		
		String body = gson.toJson(request);
		Result result = Networker.post(getRelativeURL(""), body);
		
		handleErrors(result);
		
		List<SuccessResponse> entries = safeFromJson(result.getBody(), SuccessResponse.gsonType);
		SuccessResponse response = entries.get(0);
	
		return response.success.get("username");
	}
	
	/**
	 * Unlink the current user from the bridge.
	 * @throws ApiException throws UnauthorizedException if the user no longer exists, ApiException for other errors
	 */
	public void unlink() throws IOException, ApiException {
		requireAuthentication();
		
		Result result = Networker.delete(getRelativeURL("config/whitelist/" + enc(username)));

		handleErrors(result);
	}
	
	public Date getLastSearch() throws IOException, ApiException {
		requireAuthentication();
		
		Result result = Networker.get(getRelativeURL("lights/new"));
		
		handleErrors(result);
		
		String lastScan = safeFromJson(result.getBody(), NewLightsResponse.class).lastscan;
		
		if (lastScan.equals("none")) {
			return null;
		} else if (lastScan.equals("active")) {
			return new Date();
		} else {
			try {
				return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss").parse(lastScan);
			} catch (ParseException e) {
				return null;
			}
		}
	}
	
	/**
	 * Start searching for new lights for 1 minute.
	 * A maximum amount of 15 new lights will be added.
	 * @throws ApiException throws UnauthorizedException if the user no longer exists, ApiException for other errors
	 */
	public void startSearch() throws IOException, ApiException {
		requireAuthentication();
		
		Result result = Networker.post(getRelativeURL("lights"), "");
		
		handleErrors(result);
	}
	
	/**
	 * Returns a list of lights known to the bridge.
	 * @return list of known lights 
	 * @throws ApiException throws UnauthorizedException if the user no longer exists, ApiException for other errors
	 */
	public List<Light> getLights() throws IOException, ApiException {
		requireAuthentication();
		
		Result result = Networker.get(getRelativeURL("lights"));
		
		handleErrors(result);
			
		Type responseType = new TypeToken<Map<String, Light>>(){}.getType();
		Map<String, Light> lightMap = safeFromJson(result.getBody(), responseType);
		
		ArrayList<Light> lightList = new ArrayList<Light>();
		
		for (String id : lightMap.keySet()) {
			Light light = lightMap.get(id);
			light.setId(id);
			lightList.add(light);
		}
		
		return lightList;
	}
	
	/**
	 * Returns detailed information for the given light.
	 * @param light light
	 * @return detailed light information
	 * @throws ApiException throws UnauthorizedException if the user no longer exists, ApiException for other errors
	 */
	public FullLight getLight(Light light) throws IOException, ApiException {
		requireAuthentication();
		
		Result result = Networker.get(getRelativeURL("lights/" + enc(light.getId())));
		
		handleErrors(result);
		
		FullLight fullLight = safeFromJson(result.getBody(), FullLight.class);
		fullLight.setId(light.getId());
		return fullLight;
	}
	
	/**
	 * Changes the name of the light and returns the new name.
	 * NOTE: A number will be appended to duplicate names, which may result in a new name exceeding 32 characters.
	 * @param light light
	 * @param name new name [0..32]
	 * @return new name
	 * @throws ApiException throws UnauthorizedException if the user no longer exists, ApiException for other errors
	 */
	public String setLightName(Light light, String name) throws IOException, ApiException {
		requireAuthentication();
		
		String body = gson.toJson(new SetLightNameRequest(name));
		Result result = Networker.put(getRelativeURL("lights/" + enc(light.getId())), body);
		
		handleErrors(result);
		
		List<SuccessResponse> entries = safeFromJson(result.getBody(), SuccessResponse.gsonType);
		SuccessResponse response = entries.get(0);
		
		return response.success.get("/lights/" + enc(light.getId()) + "/name");
	}
	
	/**
	 * Changes the state of a light.
	 * @param light light
	 * @param update changes to the state
	 * @throws ApiException throws UnauthorizedException if the user no longer exists, ApiException for other errors
	 */
	public void setLightState(Light light, StateUpdate update) throws IOException, ApiException {
		requireAuthentication();
		
		String body = update.toJson();
		Result result = Networker.put(getRelativeURL("lights/" + enc(light.getId()) + "/state"), body);
		
		handleErrors(result);
	}
	
	// Used as assert in requests that require authentication
	private void requireAuthentication() {
		if (this.username == null) {
			throw new IllegalStateException("linking is required before interacting with the bridge");
		}
	}
	
	// Methods that convert gson exceptions into ApiExceptions
	private <T> T safeFromJson(String json, Type typeOfT) throws ApiException {
		try {
			return gson.fromJson(json, typeOfT);
		} catch (JsonParseException e) {
			throw new ApiException("API returned unexpected result: " + e.getMessage());
		}
	}
	
	private <T> T safeFromJson(String json, Class<T> classOfT) throws ApiException {
		try {
			return gson.fromJson(json, classOfT);
		} catch (JsonParseException e) {
			throw new ApiException("API returned unexpected result: " + e.getMessage());
		}
	}
	
	// Used as assert in all requests to elegantly catch common errors
	private void handleErrors(Result result) throws IOException, ApiException {
		if (result.getResponseCode() != 200) {
			throw new IOException();
		} else {
			try {
				List<ErrorResponse> errors = gson.fromJson(result.getBody(), ErrorResponse.gsonType);
				if (errors == null) return;
				
				for (ErrorResponse error : errors) {					
					switch (error.getType()) {
					case 1:
						username = null;
						throw new UnauthorizedException(error.getDescription());
					case 101:
						throw new LinkButtonException(error.getDescription());
					default:
						throw new ApiException(error.getDescription());
					}
				}
			} catch (JsonParseException e) {
				// Not an error
			} catch (NullPointerException e) {
				// Object that looks like error
			}
		}
	}
	
	// UTF-8 URL encode
	private String enc(String str) {
		try {
			return URLEncoder.encode(str, "utf-8");
		} catch (UnsupportedEncodingException e) {
			// throw new EndOfTheWorldException()
			throw new UnsupportedOperationException("UTF-8 not supported");
		}
	}
	
	private String getRelativeURL(String path) {
		if (username == null) {
			return "http://" + ip + "/api/" + path;
		} else {
			return "http://" + ip + "/api/" + enc(username) + "/" + path;
		}
	}
}
